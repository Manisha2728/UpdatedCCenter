# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from django.db import models, migrations
import django.core.validators


class Migration(migrations.Migration):

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Group',
            fields=[
                ('id', models.IntegerField(primary_key=True, serialize=False, validators=[django.core.validators.MinValueValidator(1)], help_text=b'Defines the Group ID as an integer.<br>The Group ID must be unique in the federation.', unique=True, verbose_name=b'Id')),
                ('name', models.CharField(help_text=b'Defines a unique Group Name.', unique=True, max_length=100, verbose_name=b'Name')),
            ],
            options={
                'verbose_name': 'Federation Group',
                'history_meta_label': 'Federation Group',
            },
            bases=(models.Model,),
        ),
        migrations.CreateModel(
            name='Node',
            fields=[
                ('id', models.PositiveIntegerField(unique=True, serialize=False, primary_key=True)),
                ('uid', models.PositiveIntegerField(help_text=b'Defines the Node ID as an integer.<br>The Node ID must be unique in the federation.', unique=True, verbose_name=b'Id')),
                ('name', models.CharField(help_text=b'Defines the Node Name as text.<br>It must be unique in the federation.', unique=True, max_length=100, verbose_name=b'Name')),
                ('application_server', models.CharField(help_text=b'The name of the application server, which is the NLB.<br>It must be unique in the federation.', unique=True, max_length=100, verbose_name=b'Application Server')),
                ('pas_option_remote', models.IntegerField(default=0, help_text=b'This configuration is used to define the behavior of the Patient Consent functionality in a federated system where different nodes are configured with different Patient Consent policies (PAR).<br/>This configuration is required in order to enable each HIE participant to define and enforce its own Privacy and Consent requirements. The configuration enables each dbMotion node to define how to handle patient consent defined by other dbMotion nodes.<br/>In a federated system, a Patient Consent conflict might occur when the Patient Search returns patient indexes from different nodes (different systems) where each node has a different Patient Consent policy. The conflict is resolved by using this configuration to filter out of the Patient Search results all indexes that do not provide consent according to the consent policy of the specific node.<br/>The following guidelines apply to this configuration:<br/>- If all nodes in the federation have the same Patient Consent policy, there is no need to perform this configuration.<br/>- If different nodes have different Patient Consent policies it is mandatory to perform this configuration. If the configuration was not performed, the system uses the local Patient Consent policy definitions for all nodes.<br/>- The local node configuration applies only when exported to other nodes. The configuration for the actual local node behavior is located in: Security -> General Definition -> Defining Patient Consent Policy.<br/><i>Default: Apply local node policy</i>', verbose_name=b'Filter Federated Patient Records Policy', choices=[(0, b'Apply local node policy'), (1, b'Opt In and Most updated consent'), (2, b'Opt Out and Most updated consent'), (3, b'Opt In and Most restricted consent'), (4, b'Opt Out and Most restricted consent')])),
                ('pl_active', models.BooleanField(default=False, help_text=b'Determines whether this node provides data for the Patient List.<br/><i>Default: False.</i>', verbose_name=b'Provide to Patient List')),
                ('node_confidentiality_level', models.CharField(default=b'', help_text=b"This configuration (in Code^Code format) defines the user's confidentiality code(s) assigned to the user's Security Role, that determine whether this node's outage status is displayed in the dbMotion applications (with the red semaphore icon in the Retrieval Status table) when the node is in outage mode.<br>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;If confidentiality code(s) are not defined here, the status of this node in outage mode will be displayed with the red semaphore icon.<br>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;If the confidentiality code(s) defined here (for example, PSY code) were assigned to the user's Security Role, when this node is in outage mode the node will be displayed in the Retrieval Status table with the red semaphore icon.<br>&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;If the confidentiality code(s) defined here (for example, PSY code) were NOT assigned to the user's Security Role, when this node is in outage mode the node will NOT be displayed in the Retrieval Status table.<br>The confidentiality codes configured here must be configured in allowConfidentialityLevels configuration in the Security Management role profile.<br><br><em><u>Note:</u>&nbsp; This configuration is supported only in Israeli projects (that are implemented with the CDR Adapter).</em><br/><i>Default: Empty</i>", max_length=200, verbose_name=b'Configuring Confidentiality Codes for Display of Node Outage Indication', blank=True)),
                ('is_available_during_document_search', models.BooleanField(default=False, help_text=b'If enabled, the node can be searched and can search other Elasticsearch nodes in the federation.<br/>If disabled, the node cannot be searched or searched by other Elasticsearch nodes in the federation.<br/><b>Note:</b> Restart services "Communication Data Service" and all its dependences to apply changes.<br/><i>Default: False.</i>', verbose_name=b'Available for federated Document Search')),
                ('ppol_provider_node', models.ForeignKey(on_delete=models.SET_NULL, default=1, to='federation.Node', blank=True, help_text=b'Defines the node that provides the Provider Registry Service (PPOL).<br>It is recommended to configure an identical value for the PPOL service on each node in order to configure one single centralized PPOL service in the federation.<br>Important! If a different PPOL service is configured on each node, the clustering of Patient and Provider data cannot be achieved between the PPOL instances.<br>For example, in Collaborate events will be displayed only for those Patients or Providers that are managed within the relevant PPOL Instance.<br>The rest will be filtered out by the Data Event Monitor. Additionally, Population Health will calculate rules (for Disease Populations) only for the patient indexes in the relevant PPOL Instance, and based only on the partial clinical data that is available.', null=True, verbose_name=b'PPOL Provider Node')),
                ('request_from', models.ForeignKey(on_delete=models.SET_DEFAULT, related_name='request_from', default=-1, verbose_name=b'Retrieve from', to='federation.Group', help_text=b'Defines the Group of nodes to which this node can send requests and receive responses with data.<br>Possible values: All, None, Defined Group.<br><b>All:</b> Requesting information is applicable to all nodes including future added members. However, this might be limited by nodes that restrict the exchange of information with specified Groups.<br><b>None:</b> Requesting information outside this local node is disabled.<br><b>Defined Group:</b> Requesting information is applicable only to this Defined Group of nodes.<br>To define a Group of nodes, click the + sign to open the Federation Group window. Only one Group can be defined. To edit the Group settings, click the pencil sign.<br>When adding or changing a Group, the change applies to all configurations that refer to this Group.<br/><i>Default: None</i>')),
                ('response_to', models.ForeignKey(on_delete=models.SET_DEFAULT, related_name='response_to', default=-1, verbose_name=b'Provide to', to='federation.Group', help_text=b'Defines the Group of nodes from which this node can accept requests and provide responses with data.<br>Possible values: All, None, Defined Group.<br><b>All:</b> Providing information is applicable to all nodes including future added members. However, this might be limited by nodes that restrict the exchange of information with specified Groups.<br><b>None:</b> Providing information outside this local node is disabled. However, if a node is set to not provide data, local data is always provided to local users.<br><b>Defined Group:</b> Providing information is applicable only to this Defined Group of nodes.<br>To define a Group of nodes, click the + sign to open the Federation Group window. Only one Group can be defined. To edit the Group settings, click the pencil sign.<br>When adding or changing a Group, the change applies to all configurations that refer to this Group.<br/><i>Default: None</i>')),
            ],
            options={
                'help_text': '\n        dbMotion supports the capability to connect multiple dbMotion instances (Nodes) that natively integrate with one another.<br>\n        The connectivity of multiple Nodes is referred to as the Federation Solution. To implement a Federated Solution, perform the following configurations for all nodes on a single local node. Then export the Federation JSON file and import it to all the other nodes in the federation. After importing the JSON file or changing the node definitions click Apply. No service restart is required.<br>\n        The Export and Import process assures alignment of all configurations between all nodes in the federation. It is not recommended to configure this alignment manually on each node.<br><br>\n        \n        The system identifies the local node and configures it as isLocal (true) automatically by recognizing the local application server name. The isLocal setting cannot be manually configured. Additionally, after each of the nodes import the JSON files, the isLocal (true) configuration is set automatically for the local node.<br><br> \n        \n        To add a node, click Add Federation Node and follow the instructions.<br> \n        To delete a node, select the required row and click Action -> Delete. Then click Go.<br>\n        To change a node configuration, click on the node name or ID and edit the node properties as required.<br><br>\n        \n        <b>Symmetric Topology</b> (where all nodes use identical federation settings) is highly recommended. In some cases, a single member might change the federation configurations locally, apply and test the changes prior to sharing the settings with all other nodes. During the test, the network is <b>asymmetric</b> and the configurations are applied differentially at each node.\n        ',
                'verbose_name': 'Federation Node',
                'history_meta_label': 'Federation Node',
            },
            bases=(models.Model,),
        ),
        migrations.AddField(
            model_name='group',
            name='node',
            field=models.ManyToManyField(help_text=b'Defines the nodes included in the Federation Group. Select the nodes from the dropdown menu.<br>Possible values: A Group can contain all nodes, specified nodes, or no nodes. Different Groups can have overlapping members.<br><br><b>To Delete a Group:</b> Because of references to the Group in various configurations, it is recommended to change the Group Name to Deleted and remove all group members. The Group remains available in the dropdown menu and can be referenced again and updated in the future. The behavior of an empty group is similar to a group with no (None) members.', to='federation.Node', null=True, verbose_name=b'Nodes', blank=True),
            preserve_default=True,
        ),
    ]
